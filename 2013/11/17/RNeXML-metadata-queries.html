<p>(From issue <a href="https://github.com/ropensci/RNeXML/issues/20">#20</a>)</p>
<h3 id="basic-metadata-queries">Basic metadata queries</h3>
<p>a question of how the user queries that metadata. Currently we have a <code>metadata</code> function that simply extracts all the metadata at the specified level (nexml, otus, trees, tree, etc) and returns a named character string in which the name corresponds to the <code>rel</code> or <code>property</code> and the value corresponds to the <code>content</code> or <code>href</code>, e.g.:</p>
<pre class="sourceCode r"><code class="sourceCode r">birds &lt;-<span class="st"> </span><span class="kw">read.nexml</span>(<span class="st">&quot;birdOrders.xml&quot;</span>)
meta &lt;-<span class="st"> </span><span class="kw">get_metadata</span>(birds) </code></pre>
<p>prints the named string with the top-level (default-level) metadata elements as so:</p>
<pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>meta 
##                                             dc:date 
##                                        &quot;2013-11-17&quot; 
##                                          cc:license 
## &quot;http://creativecommons.org/publicdomain/zero/1.0/&quot;</code></pre>
<p>Which we can subset by name, e.g. <code>meta[&quot;dc:date&quot;]</code>. This is probably simplest to most R users; though exactly what the namespace prefix means may be unclear if they haven’t worked with namespaces before. (The user can always print a summary of the namespaces and prefixes in the nexml file using <code>birds@namespaces</code>).</p>
<p>This approach is simple, albeit a bit limited.</p>
<h3 id="xpath-queries">XPath queries</h3>
<p>For instance, the R user has a much more natural and powerful way to handle these issues of prefixes and namespaces using either the XML or rrdf libraries. For instance, if we extract meta nodes into RDF-XML, we could handle the queries like so:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xpathSApply</span>(meta, <span class="st">&quot;//dc:title&quot;</span>, xmlValue)</code></pre>
<p>which uses the namespace prefix defined in the nexml; or</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xpathSApply</span>(meta, <span class="st">&quot;//x:title&quot;</span>, xmlValue, <span class="dt">namespaces=</span><span class="kw">c</span>(<span class="dt">x =</span> <span class="st">&quot;http://purl.org/dc/elements/1.1/&quot;</span>))</code></pre>
<p>defining the custom prefix <code>x</code> to the URI</p>
<h3 id="sparql-queries">Sparql queries</h3>
<p>Pretty exciting that qe can make arbitrary SPARQL queries of the metadata as well.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rrdf)
<span class="kw">sparql.rdf</span>(ex, <span class="st">&quot;SELECT ?title WHERE { ?x &lt;http://purl.org/dc/elements/1.1/title&gt; ?title })</span></code></pre>
<p>Obviously the XPath or SPARQL queries are more expressive / powerful than drawing out the metadata from the S4 structure directly. On the other hand, because both of these approaches use just the distilled metadata, the original connection between metadata elements and the structure of the XML tree is lost unless stated explicitly. An in-between solution is to use XPath on the nexml XML instead, though I think we cannot make use of the namespaces in that case, since they appear in attribute values rather than structure.</p>
<p>Anyway, it’s nice to have these options in R, particularly for more complex queries where we might want to make some use of the ontology as well. On the other hand, simple presentation of basic metadata is probably necessary for most users.</p>
<p>Would be nice to illustrate with a query that required some logical deduction from the ontology.</p>
